{
  "@metadata": {
    "author": "BuyMyBeard",
    "last-updated": "2024-07-30",
    "locale": "en"
  },
  "home": "Home",
  "game-jams": "Game Jams",
  "other-projects": "Other Projects",
  "animation": "Animation",
  "technical-art": "Technical Art",
  "programming": "Programming",
  "my-github-profile": "My GitHub profile",
  "contact-me": "Contact me",
  "home-title": "BuyMyBeard's Portfolio",
  "home-p1": "Hey, I'm <b>Alexandre \"BuyMyBeard\" Lacombe</b>, and I make games!",
  "home-p2": "I am currently working fulltime at DevXpress as a mobile developper. I am formely taught through techniques de l'informatique at Collège Lionel-Groulx.",
  "home-p3": "In addition to my studies, I pursue programming as a hobby, participating in various game jams and undertaking side projects. Notably, I achieved <b>1<sup>st</sup> place</b> in Gamedev.js 2023's open-source category and was <a href=\"https://github.blog/2023-06-21-gamedev-js-2023/\">featured on The GitHub Blog</a>!",
  "home-p4": "I am currently seeking opportunities in the game industry within the Montréal region,  mainly for gameplay programming . Additionally, I am self-teaching various tech-art disciplines with the aim of becoming a Tech Artist in the future!",
  "broadphase-title": "Physics Engine Broad Phase",
  "language": "Language",
  "project": "Project",
  "source-code": "Source code",
  "broadphase-p1": "For a bit of context, all physics engine implement a broad phase, to avoid checking collision for every single pair in a simulation.",
  "broadphase-p2": "In this case, I implemented the <a href=\"https://en.wikipedia.org/wiki/Sweep_and_prune\">Sweep and prune algorithm</a> for my simulation.",
  "broadphase-p3": "The approach here is to use the axis-aligned bounding box of every shape and compare the x-axis boundaries. If two bodies overlap, the pair are saved in an array, and then returned at the end of the method body. This is done by sorting the bodies by the the left boundary of their bounding box, and then sweeping through to check for overlaps.",
  "broadphase-p4": "What makes this especially efficient, is that the array is most often almost sorted, since a physics step will almost never move a body much. <code>Array.prototype.sort()</code>, the method used here, varies its implementation depending on the browser, but most of the time, this is done with the <a href=\"https://en.wikipedia.org/wiki/Timsort\">Timsort algorithm</a>, which is well-suited for arrays that are already partially sorted.",
  "broadphase-p5": "That is why the body array is mutated as a side effect within the method body, so that the next step can reuse the sorted array from the previous step to avoid unnecessary work.",
  "parser-title": "Command Line Parser",
  "parser-p1": "This snippet of code shows the command line argument parser I wrote in Rust.",
  "parser-p2": "What I think makes this notable is a clever use of a peekable Vec iterator to send to <code>parse_flag()</code the next argument so it can process flags with optional arguments.",
  "parser-p3": "For example, the command <code>head -n 5 ./README.md</code> can be parsed while acknowledging that <code>5</code> is an argument for the flag <code>-n</code>.",
  "parser-p4": "<code>parse_flag()</code> will then return a tuple containing a <b>Flag</b>, and the enum <code>FlagArg</code>. If the flag has an argument, the iterator will skip that one before processing the next argument."
}
