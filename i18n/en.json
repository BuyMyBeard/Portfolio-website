{
  "@metadata": {
    "author": "BuyMyBeard",
    "last-updated": "2024-07-30",
    "locale": "en"
  },
  "home": "Home",
  "game-jams": "Game Jams",
  "other-projects": "Other Projects",
  "animation": "Animation",
  "technical-art": "Technical Art",
  "programming": "Programming",
  
  "broadphase-title": "Physics Engine Broad Phase",
  "language": "Language",
  "project": "Project",
  "source-code": "Source code",
  "broadphase-p1": "For a bit of context, all physics engine implement a broad phase, to avoid checking collision for every single pair in a simulation.",
  "broadphase-p2": "In this case, I implemented the <a href=\"https://en.wikipedia.org/wiki/Sweep_and_prune\">Sweep and prune algorithm</a> for my simulation.",
  "broadphase-p3": "The approach here is to use the axis-aligned bounding box of every shape and compare the x-axis boundaries. If two bodies overlap, the pair are saved in an array, and then returned at the end of the method body. This is done by sorting the bodies by the the left boundary of their bounding box, and then sweeping through to check for overlaps.",
  "broadphase-p4": "What makes this especially efficient, is that the array is most often almost sorted, since a physics step will almost never move a body much. <code>Array.prototype.sort()</code>, the method used here, varies its implementation depending on the browser, but most of the time, this is done with the <a href=\"https://en.wikipedia.org/wiki/Timsort\">Timsort algorithm</a>, which is well-suited for arrays that are already partially sorted.",
  "broadphase-p5": "That is why the body array is mutated as a side effect within the method body, so that the next step can reuse the sorted array from the previous step to avoid unnecessary work.",
  "parser-title": "Command Line Parser",
  "parser-p1": "This snippet of code shows the command line argument parser I wrote in Rust.",
  "parser-p2": "What I think makes this notable is a clever use of a peekable Vec iterator to send to <code>parse_flag()</code the next argument so it can process flags with optional arguments.",
  "parser-p3": "For example, the command <code>head -n 5 ./README.md</code> can be parsed while acknowledging that <code>5</code> is an argument for the flag <code>-n</code>.",
  "parser-p4": "<code>parse_flag()</code> will then return a tuple containing a Flag, and the enum <code>FlagArg</code>. If the flag has an argument, the iterator will skip that one before processing the next argument."
}
