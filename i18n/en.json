{
  "@metadata": {
    "author": "BuyMyBeard",
    "last-updated": "2024-08-04",
    "locale": "en"
  },
  "light": "Light",
  "dark": "Dark",
  "home": "Home",
  "game-jams": "Game Jams",
  "other-projects": "Other Projects",
  "animation": "Animation",
  "technical-art": "Technical Art",
  "programming": "Programming",
  "my-github-profile": "My GitHub profile",
  "contact-me": "Contact me",
  "language": "Language",
  "project": "Project",
  "source-code": "Source code",
  "home-title": "BuyMyBeard's Portfolio",
  "home-p1": "Hey, I'm <b>Alexandre \"BuyMyBeard\" Lacombe</b>, and I make games!",
  "home-p2": "I am currently working fulltime at DevXpress as a mobile developper. I am formely taught through techniques de l'informatique at Collège Lionel-Groulx.",
  "home-p3": "In addition to my studies, I pursue programming as a hobby, participating in various game jams and undertaking side projects. Notably, I achieved <b>1<sup>st</sup> place</b> in Gamedev.js 2023's open-source category and was <a href=\"https://github.blog/2023-06-21-gamedev-js-2023/\">featured on The GitHub Blog</a>!",
  "home-p4": "I am currently seeking opportunities in the game industry within the Montréal region,  mainly for gameplay programming . Additionally, I am self-teaching various tech-art disciplines with the aim of becoming a Tech Artist in the future!",
  "game-jams-p1": "Please check out my showcase video for all the jam games I made in 2022-2023!",
  "game-jams-nav-header": "Games (In reverse chronological order)",
  "made-in": "Made in",
  "weeks-for": "weeks for",
  "days-for": "days for",
  "hours-for": "hours for",
  "theme": "Theme",
  "team-size": "Team size",
  "download": "Download",
  "play-in-browser": "Play in the browser",
  "spectra-hunt-p1": "This Jam made me learn to rig and animate quadrupeds in <b>Blender</b>, and create cutscenes with the Unity Timeline. It was an occasion to experiment with shaders and visual effects to create a beautiful low-poly flat-shaded environment.",
  "spectra-hunt-p2": "I am especially proud of the dynamic clouds casting moving shadows on the map, and the custom water shader with planar reflections.",
  "homework-havoc-p1": "This jam was made with Phaser 3 and TypeScript, and was my first time producing my own sound effects. It also had been a while since I produced my own 2d texture assets, dating from <a href=\"#dazel-the-gazelle\">Dazel the Gazelle</a>.",
  "homework-havoc-p2": "The biggest challenge of this jam was creating the stack system for the paper sheets. It was slightly inspired by systems like the one in <a href=\"https://papersplea.se/\">Papers, Please</a>, but instead of shifting the item you were dragging to the top of the rendering order, you have to slip it through to place it on the top.",
  "official-website-french-only": "Official website (French only)",
  "neon-souls-p1": "Integration project of Collège Lionel-Groulx, made as a team of 4 over 11 weeks. The game features a full-on Souls style fighting system, with a variety of enemy behaviour, stamina and health management, upgrades and map to explore, with a double boss encounter at the end to test the player's mettle.",
  "playground-with-input-mapping": "<a href=\"https://buymybeard.github.io/pixi-physics/\">Playground</a> with <a href=\"https://github.com/BuyMyBeard/pixi-physics/blob/main/TestingInputs.md\">input mapping</a>",
  "pixi-physics-p1": "pixi-physics is a 2d physics engine built as a plugin for the <a href=\"https://pixijs.com/\">Pixijs 2d rendering engine</a>.",
  "pixi-physics-p2": "It supports collision detection and collision response between circle and polygon rigid bodies. Bodies have customizable friction and restitution, can be static, and events can be intercepted for collision events.",
  "pixi-physics-p3": "The x movement, y movement, and rotation can be locked, and forces and impulses can be applied to the bodies. There is also a layer system, allowing to not make specific bodies interact with each other.",
  "pixi-physics-p4": "The engine supports multiple broad phases :",
  "uniform-grid-partitioning": "<a href=\"https://en.wikipedia.org/wiki/Space_partitioning\">uniform grid partitioning</a>",
  "kd-tree": "<a href=\"https://en.wikipedia.org/wiki/K-d_tree\">k-d tree</a>",
  "test-in-browser": "Test in browser",
  "star-pattern-p1": "A recreation of the animated star background seen in Persona 5. The effect was done using GLSL fragment shaders, and <a href=\"https://pixijs.com\">Pixijs</a> to render different versions of the shader with varying offset and color placed all over the screen.",
  "model-viewer-instructions": "You can rotate and zoom the models by dragging around the canvas, and control the animations with the GUI on the left.",
  "arctic-fox": "Arctic Fox",
  "white-hare": "White Hare",
  "swordsman-player": "Swordsman Player",
  "swordsman-enemy": "Swordsman Enemy",
  "ranged-enemy": "Ranged Enemy",
  "arctic-fox-p1": "This model was weight-painted, rigged, and animated for <a href=\"./game-jams.html#spectra-hunt\">Spectra Hunt</a>. It was my first attempt at animating quadrupeds, and the most challenging aspect was understanding the anatomy of a mammal.",
  "arctic-fox-p2": "To animate it, I had to review in .25x speed footage of foxes walking and running around. It was brought to life with a few procedural animations in engine.",
  "white-hare-p1": "This model was animated along the fox for <a href=\"./game-jams.html#spectra-hunt\">Spectra Hunt</a>.",
  "white-hare-p2": "One major challenge along with the fox was to weight paint the models. The issue with low poly models is that deformations can get pretty ugly if care is not given. I had to edit some geometry on the hare to make it deformable without making the model collapse on itself.",
  "swordsman-player-p1": "<a href=\"./other-projects.html#neon-souls\">Neon Souls</a>'s biggest challenge was definitely the scope of the animation system for the game. 90 animation clips were produced in total, split amongst the player and the different type of enemies in the game.",
  "swordsman-player-p2": "The player was the starting point, and I don't look back too fondly and my first walk cycle, though other clips, like the rolling animation, came out beautifully.",
  "swordsman-enemy-p1": "<a href=\"./other-projects.html#neon-souls\">Neon Souls</a> is a Soulslike, so enemy variety was important. It was not feasible to model and rig other characters, so the model was reused, but given different animations. This enemy has a different pose from the player, and even possesses the bosses's attacks, since they are a reskin of the base enemy with scaled-up model and different swords.",
  "ranged-enemy-p1": "Finally, a ranged enemy was added into the game to make the player approach fights differently. This one sticks his ground and shoots at the player periodically when he detects him, but will use some different moves as retaliation if the player is too close.",
  "broadphase-title": "Physics Engine Broad Phase",
  "broadphase-p1": "For a bit of context, all physics engine implement a broad phase, to avoid checking collision for every single pair in a simulation.",
  "broadphase-p2": "In this case, I implemented the <a href=\"https://en.wikipedia.org/wiki/Sweep_and_prune\">Sweep and prune algorithm</a> for my simulation.",
  "broadphase-p3": "The approach here is to use the axis-aligned bounding box of every shape and compare the x-axis boundaries. If two bodies overlap, the pair are saved in an array, and then returned at the end of the method body. This is done by sorting the bodies by the the left boundary of their bounding box, and then sweeping through to check for overlaps.",
  "broadphase-p4": "What makes this especially efficient, is that the array is most often almost sorted, since a physics step will almost never move a body much. <code>Array.prototype.sort()</code>, the method used here, varies its implementation depending on the browser, but most of the time, this is done with the <a href=\"https://en.wikipedia.org/wiki/Timsort\">Timsort algorithm</a>, which is well-suited for arrays that are already partially sorted.",
  "broadphase-p5": "That is why the body array is mutated as a side effect within the method body, so that the next step can reuse the sorted array from the previous step to avoid unnecessary work.",
  "parser-title": "Command Line Parser",
  "parser-p1": "This snippet of code shows the command line argument parser I wrote in Rust.",
  "parser-p2": "What I think makes this notable is a clever use of a peekable Vec iterator to send to <code>parse_flag()</code the next argument so it can process flags with optional arguments.",
  "parser-p3": "For example, the command <code>head -n 5 ./README.md</code> can be parsed while acknowledging that <code>5</code> is an argument for the flag <code>-n</code>.",
  "parser-p4": "<code>parse_flag()</code> will then return a tuple containing a <b>Flag</b>, and the enum <code>FlagArg</code>. If the flag has an argument, the iterator will skip that one before processing the next argument.",
  "star-pattern-shader": "Star Pattern Shader"
}
