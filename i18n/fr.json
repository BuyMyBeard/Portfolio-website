{
  "@metadata": {
    "author": "BuyMyBeard",
    "last-updated": "2024-08-04",
    "locale": "fr"
  },
  "light": "Clair",
  "dark": "Sombre",
  "home": "Accueil",
  "game-jams": "Game Jams",
  "other-projects": "Projets divers",
  "animation": "Animation",
  "technical-art": "Art technique",
  "programming": "Programmation",
  "my-github-profile": "Mon profil GitHub",
  "contact-me": "Me contacter",
  "broadphase-title": "Phase large de moteur physique",
  "language": "Langage",
  "project": "Projet",
  "source-code": "Code source",
  "home-title": "Portfolio de BuyMyBeard",
  "home-p1": "Hey, je suis <b>Alexandre \"BuyMyBeard\" Lacombe</b>, et je développe des jeux!",
  "home-p2": "Je suis présentement employé à DevXpress en tant que développeur d'application mobile. J'ai atteint un diplôme de techniques de l'informatique à Lionel-groulx.",
  "home-p3": "En plus de mon travail, je programme récréationnellement en participant à des Game Jams et en entreprenant des projets personnels. J'ai remporté la <b>1<sup>ère</sup> place</b> pour la catégorie open-source de Gamedev.js 2023 et était <a href=\"https://github.blog/2023-06-21-gamedev-js-2023/\">en vedette sur Le GitHub Blog</a>!",
  "home-p4": "Je suis à la recherche d'opportunités dans l'industrie du jeu vidéo, principalement en programmation de gameplay. Additionellement, je m'autoforme sur différentes disciplines de tech-art dans le but de devenir un artiste technique dans le futur!",
  "game-jams-p1": "Vous pouvez visionner la vidéo de démonstration de tous les jeux de jam que j'ai fait en 2022-2023!",
  "game-jams-nav-header": "Jeux (En ordre chronologique inverse)",
  "made-in": "Fait en",
  "weeks-for": "semaines pour",
  "days-for": "jours pour",
  "hours-for": "heures pour",
  "theme": "Thème",
  "team-size": "Taille de l'équipe",
  "download": "Télécharger",
  "play-in-browser": "Jouer dans le navigateur",
  "spectra-hunt-p1": "Ce jam m'a permis d'apprendre le rigging 3D et à animer des quadrupèdes dans <b>Blender</b>, puis créer des cinématiques avec la Unity Timeline. J'ai aussi eu l'occasion d'expérimenter avec des nuanceurs et des effets visuels pour créer un magnifique environnement bas-poly avec ombrage plat.",
  "spectra-hunt-p2": "Je suis particulièrement fier des nuages dynamiques, qui projettent de l'ombre se déplaçant sur le monde, ainsi que le nuanceur d'eau avec réflections planaires.",
  "homework-havoc-p1": "Ce jam a été développé avec Phaser 3 et TypeScript, et a été le premier jam où j'ai produit mes propres effets sonores. J'ai aussi produit mes propres ressources de texture 2D, ce que j'ai fait la dernière fois pour <a href=\"#dazel-the-gazelle\">Dazel the Gazelle</a>",
  "homework-havoc-p2": "Le plus grand défi lors de ce jam a été le système de pile pour les éléments interactifs. Le système est légèrement inspiré du système trouvé dans <a href=\"https://papersplea.se/\">Papers, Please</a>, mais la différence majeure est que plutôt que les objets soient mis au sommet de la pile suite à une interaction, il faut les faufiler au travers des autres objets pour les sortir.",
  "official-website-french-only": "Site officiel",
  "neon-souls-p1": "Projet d'intégration de ma formation au collège Lionel-Groulx, développé en équipe de 4 pendant une durée de 11 semaines. Le jeu incorpore les mécaniques de combat typique d'un jeu style Souls, avec une variété de comportements enemis, la gestion de la vie et de l'endurance, des améliorations, un monde explorable, ainsi qu'un double boss pour tester les compétences du joueur.",
  "playground-with-input-mapping": "<a href=\"https://buymybeard.github.io/pixi-physics/\">Démonstration interactive</a> avec <a href=\"https://github.com/BuyMyBeard/pixi-physics/blob/main/TestingInputs.md\">contrôles</a>",
  "pixi-physics-p1": "pixi-physics est un moteur physique et un module pour le <a href=\"https://pixijs.com/\">moteur graphique 2D Pixijs</a>.",
  "pixi-physics-p2": "Le moteur supporte la détection de collision et les réponses physiques entre les corps rigides en forme de cercle ou de polygone. Les corps peuvent avoir leur propre friction et restitution, être statique, et il est possible d'intercepter les événements de collisions.",
  "pixi-physics-p3": "Le mouvement sur l'axe des x et des y ainsi que la rotation peut être bloquée, et des forces et impulsions peuvent être appliquées sur les corps. Il existe aussi un système de couches, permettant d'ignorer les interactions entre certains corps.",
  "pixi-physics-p4": "Le moteur supporte plusieurs algorithmes de phase large :",
  "uniform-grid-partitioning": "<a href=\"https://en.wikipedia.org/wiki/Space_partitioning\">partitionement en grille uniforme</a>",
  "kd-tree": "<a href=\"https://fr.wikipedia.org/wiki/Arbre_kd\">arbre k-dimensionel</a>",
  "test-in-browser": "Tester dans le navigateur",
  "star-pattern-p1": "Une récréation du fond d'étoiles animées trouvé dans Persona 5. L'effet est accompli à l'aide d'un programme de nuanceur de fragment, et <a href=\"https://pixijs.com\">Pixijs</a> permet d'instancier ce matériel appliqué à plusieurs sprites avec différentes couleurs partout sur l'écran.",
  "model-viewer-instructions": "Tous les modèles sur cette page sont interactifs. Il est possible de déplacer et zoom la caméra en appuyant dans les canvas, puis de contrôler les animations avec l'interface à gauche.",
  "arctic-fox": "Renard polaire",
  "white-hare": "Lièvre blanc",
  "swordsman-player": "Joueur épéiste",
  "swordsman-enemy": "Ennemi épéiste",
  "ranged-enemy": "Ennemi tireur",
  "broadphase-p1": "Pour vous mettre en contexte, tous les moteurs physiques implémentent une phase large, ce qui permet d'éviter de vérifier s'il y a une collision entre chaque paire unique dans la simulation.",
  "broadphase-p2": "Dans mon implémentation, j'ai choisi principalement l'<a href=\"https://en.wikipedia.org/wiki/Sweep_and_prune\">algorithme Sweep and prune</a> pour ma simulation.",
  "broadphase-p3": "L'approche de cette algorithme est d'utiliser la boîte englobante alignée sur les axes (AABB) de chaque forme et de comparer les limites sur l'axe x. Si les deux corps se chevauchent, ils sont ajoutés dans un tableau qui est retourné à la fin du corps. Les formes sont premièrement triés par la limite gauche de leur boîte limitante, puis le tableau est balayé pour trouver un chevauchement.",
  "broadphase-p4": "Un aspect qui rend cette approche très efficace est que puisque un pas dans la simulation bouge la plupart des corps très peu, l'ordre est peu changé, et donc le tableau toujours presque trié. La méthode <code>Array.prototype.sort()</code>, bien qu'elle varie son implémentation d'un navigateur à l'autre, implémente en général l'<a href=\"https://fr.wikipedia.org/wiki/Timsort\">algorithme Timsort</a>, qui est idéal pour les tableaux sont déjà partiellement triées.",
  "broadphase-p5": "That is why the body array is mutated as a side effect within the method body, so that the next step can reuse the sorted array from the previous step to avoid unnecessary work.",
  "parser-title": "Analyse syntaxique de ligne de commande",
  "parser-p1": "Cet extrait de code est une démonstration de l'analyseur syntaxique que j'ai écris en Rust pour la ligne de commande",
  "parser-p2": "Ce que je crois rend cet exemple remarquable est l'utilisation judicieuse d'un itérateur de vecteur peekable Vec iterator pour envoyer en paramètre à <code>parse_flag()</code le prochain argument sans avancer l'itérateur inutilemnent, et pour permettre de traiter les arguments optionels sur les flags.",
  "parser-p3": "Par exemple, la commande <code>head -n 5 ./README.md</code>, lorsque traduite, sais que <code>5</code> est un argument appartenant au flag <code>-n</code>.",
  "parser-p4": "<code>parse_flag()</code> retourne un tuple contenant un <b>Flag</b> et l'énumération <code>FlagArg</code>. Si le flag possède un argument, l'itérateur sautera par dessus avant d'analyser l'argument suivant."
}
